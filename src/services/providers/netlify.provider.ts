/**
 * Netlify Provider Implementation
 * Handles OAuth and Environment Variables API for Netlify
 *
 * Uses standard OAuth2 Authorization Code Grant flow.
 * Netlify environment variables are scoped to contexts (production, deploy-preview, etc.)
 */

import {
  Provider,
  TokenResponse,
  ProviderProject,
  ProviderEnvVar,
  ProviderUser,
  registerProvider,
} from './base.provider';
import { config } from '../../config';
import { logger } from '../../utils/sharedLogger';

const NETLIFY_API_BASE = 'https://api.netlify.com/api/v1';
const NETLIFY_AUTH_BASE = 'https://app.netlify.com';
const NETLIFY_TOKEN_ENDPOINT = 'https://api.netlify.com/oauth/token';

const DEFAULT_TIMEOUT_MS = 30000; // 30 seconds

// System variables to ignore during sync (auto-generated by Netlify)
const IGNORED_VAR_PREFIXES = ['NETLIFY_'];

interface NetlifyApiError {
  error?: string;
  error_description?: string;
  message?: string;
}

class NetlifyProviderError extends Error {
  constructor(
    message: string,
    public code?: string,
    public status?: number
  ) {
    super(message);
    this.name = 'NetlifyProviderError';
  }
}

async function netlifyFetch<T>(
  url: string,
  accessToken: string,
  options: RequestInit = {},
  timeoutMs = DEFAULT_TIMEOUT_MS
): Promise<T> {
  const controller = new AbortController();
  const timeout = setTimeout(() => controller.abort(), timeoutMs);

  try {
    const response = await fetch(url, {
      ...options,
      signal: controller.signal,
      headers: {
        Authorization: `Bearer ${accessToken}`,
        'Content-Type': 'application/json',
        ...options.headers,
      },
    });

    // Handle rate limiting
    if (response.status === 429) {
      const retryAfter = response.headers.get('Retry-After');
      throw new NetlifyProviderError(
        `Rate limited by Netlify API. Retry after ${retryAfter || 'a few'} seconds.`,
        'rate_limited',
        429
      );
    }

    // Parse JSON with error handling
    let data: T & NetlifyApiError;
    try {
      data = await response.json() as T & NetlifyApiError;
    } catch {
      throw new NetlifyProviderError(
        `Netlify API returned invalid response: ${response.status} ${response.statusText}`,
        'invalid_response',
        response.status
      );
    }

    if (!response.ok) {
      throw new NetlifyProviderError(
        data.error_description || data.message || data.error || `Netlify API error: ${response.status}`,
        data.error,
        response.status
      );
    }

    return data;
  } catch (error) {
    // Handle abort/timeout
    if (error instanceof Error && error.name === 'AbortError') {
      throw new NetlifyProviderError(
        `Request to Netlify API timed out after ${timeoutMs / 1000}s`,
        'timeout',
        0
      );
    }
    // Handle network errors
    if (error instanceof TypeError && error.message.includes('fetch')) {
      throw new NetlifyProviderError(
        'Network error connecting to Netlify API. Check your internet connection.',
        'network_error',
        0
      );
    }
    throw error;
  } finally {
    clearTimeout(timeout);
  }
}

// Netlify API response types
interface NetlifySite {
  id: string;
  name: string;
  url: string;
  admin_url: string;
  account_id: string;
  account_name?: string;
  account_slug?: string;
  build_settings?: {
    repo_url?: string;
    repo_type?: string;
  };
}

interface NetlifyEnvVar {
  key: string;
  scopes: string[];
  values: Array<{
    id: string;
    value: string;
    context: string;
  }>;
  is_secret: boolean;
  updated_at: string;
  created_at: string;
}

interface NetlifyUser {
  id: string;
  slug: string;
  full_name: string;
  email: string;
  avatar_url: string;
}

export const netlifyProvider: Provider = {
  name: 'netlify',
  displayName: 'Netlify',

  getAuthorizationUrl(state: string, redirectUri: string): { url: string; codeVerifier?: string } {
    const params = new URLSearchParams({
      client_id: config.netlify?.clientId || '',
      response_type: 'code',
      redirect_uri: redirectUri,
      state,
    });

    return {
      url: `${NETLIFY_AUTH_BASE}/authorize?${params.toString()}`,
    };
  },

  async exchangeCodeForToken(code: string, redirectUri: string): Promise<TokenResponse> {
    // Netlify requires form-urlencoded body, NOT query params
    const body = new URLSearchParams({
      grant_type: 'authorization_code',
      code,
      client_id: config.netlify?.clientId || '',
      client_secret: config.netlify?.clientSecret || '',
      redirect_uri: redirectUri,
    });

    const response = await fetch(NETLIFY_TOKEN_ENDPOINT, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
      },
      body,
    });

    const data = await response.json() as {
      access_token?: string;
      token_type?: string;
      refresh_token?: string;
      error?: string;
      error_description?: string;
    };

    if (!response.ok || !data.access_token) {
      throw new NetlifyProviderError(
        data.error_description || data.error || 'Failed to exchange code for token',
        data.error,
        response.status
      );
    }

    return {
      accessToken: data.access_token,
      tokenType: data.token_type || 'Bearer',
      refreshToken: data.refresh_token,
    };
  },

  async getUser(accessToken: string): Promise<ProviderUser> {
    const data = await netlifyFetch<NetlifyUser>(
      `${NETLIFY_API_BASE}/user`,
      accessToken
    );

    return {
      id: data.id,
      username: data.slug || data.full_name,
      email: data.email,
    };
  },

  async listProjects(accessToken: string): Promise<ProviderProject[]> {
    const sites = await netlifyFetch<NetlifySite[]>(
      `${NETLIFY_API_BASE}/sites`,
      accessToken
    );

    return sites.map(site => ({
      id: site.id,
      name: site.name,
      linkedRepo: site.build_settings?.repo_url?.replace('https://github.com/', '').replace(/\.git$/, ''),
    }));
  },

  async getProject(accessToken: string, siteId: string): Promise<ProviderProject | null> {
    try {
      const site = await netlifyFetch<NetlifySite>(
        `${NETLIFY_API_BASE}/sites/${siteId}`,
        accessToken
      );

      return {
        id: site.id,
        name: site.name,
        linkedRepo: site.build_settings?.repo_url?.replace('https://github.com/', '').replace(/\.git$/, ''),
      };
    } catch (error) {
      if (error instanceof NetlifyProviderError && error.status === 404) {
        return null;
      }
      throw error;
    }
  },

  async listEnvVars(
    accessToken: string,
    siteId: string,
    environment: string
  ): Promise<ProviderEnvVar[]> {
    // First, get the site to retrieve the account_id (required for new API)
    logger.debug({ siteId }, 'Fetching site info to get account_id');
    const site = await netlifyFetch<NetlifySite>(
      `${NETLIFY_API_BASE}/sites/${siteId}`,
      accessToken
    );
    logger.debug({ siteId, accountId: site.account_id, accountName: site.account_name }, 'Got site info');

    // Use account-level endpoint (site-level was deprecated Feb 2023)
    const envUrl = `${NETLIFY_API_BASE}/accounts/${site.account_id}/env?site_id=${siteId}`;
    logger.debug({ envUrl, environment }, 'Fetching env vars from account-level endpoint');

    const vars = await netlifyFetch<NetlifyEnvVar[]>(
      envUrl,
      accessToken
    );

    // Filter by context and exclude system variables
    return vars
      .filter(v => !IGNORED_VAR_PREFIXES.some(prefix => v.key.startsWith(prefix)))
      // Only include vars that have a value for the requested context or 'all'
      .filter(v => v.values?.some(val => val.context === environment || val.context === 'all'))
      .map(v => {
        // Prefer specific context, fall back to 'all'
        const contextValue = v.values?.find(val => val.context === environment)
          || v.values?.find(val => val.context === 'all');
        return {
          key: v.key,
          // is_secret vars cannot be read after creation - value is undefined but key is included
          value: v.is_secret ? undefined : contextValue?.value,
          target: v.values?.map(val => val.context),
          type: v.is_secret ? 'secret' : 'plain',
          createdAt: new Date(v.created_at),
          updatedAt: new Date(v.updated_at),
        };
      });
  },

  async setEnvVars(
    accessToken: string,
    siteId: string,
    environment: string,
    vars: Record<string, string>
  ): Promise<{ created: number; updated: number; failed: number; failedKeys: string[] }> {
    // First, get the site to retrieve the account_id (required for new API)
    logger.debug({ siteId, environment, varCount: Object.keys(vars).length }, 'Starting setEnvVars');
    const site = await netlifyFetch<NetlifySite>(
      `${NETLIFY_API_BASE}/sites/${siteId}`,
      accessToken
    );
    const accountId = site.account_id;
    logger.debug({ siteId, accountId, accountName: site.account_name }, 'Got site info for setEnvVars');

    // Get existing vars to determine create vs update (using account-level endpoint)
    const envUrl = `${NETLIFY_API_BASE}/accounts/${accountId}/env?site_id=${siteId}`;
    logger.debug({ envUrl }, 'Fetching existing env vars');
    const existingVars = await netlifyFetch<NetlifyEnvVar[]>(
      envUrl,
      accessToken
    );
    const existingKeys = new Set(existingVars.map(v => v.key));
    logger.debug({ existingCount: existingVars.length, existingKeys: Array.from(existingKeys) }, 'Got existing env vars');

    let created = 0;
    let updated = 0;
    let failed = 0;
    const failedKeys: string[] = [];

    // Separate new vars from existing vars
    const newVarsEntries = Object.entries(vars).filter(([key]) => !existingKeys.has(key));
    const existingVarsEntries = Object.entries(vars).filter(([key]) => existingKeys.has(key));
    logger.debug({ newCount: newVarsEntries.length, updateCount: existingVarsEntries.length }, 'Separated vars for create vs update');

    // Bulk create new vars (Netlify supports this via account-level endpoint)
    if (newVarsEntries.length > 0) {
      const newVarsPayload = newVarsEntries.map(([key, value]) => ({
        key,
        scopes: ['builds', 'functions', 'runtime'],
        values: [{ context: environment, value }],
      }));

      const createUrl = `${NETLIFY_API_BASE}/accounts/${accountId}/env?site_id=${siteId}`;
      logger.debug({ createUrl, keys: newVarsEntries.map(([k]) => k) }, 'Bulk creating new env vars');

      try {
        await netlifyFetch(
          createUrl,
          accessToken,
          {
            method: 'POST',
            body: JSON.stringify(newVarsPayload),
          }
        );
        created = newVarsEntries.length;
        logger.info({ siteId, created, environment }, 'Successfully bulk created env vars');
      } catch (error) {
        failed += newVarsEntries.length;
        failedKeys.push(...newVarsEntries.map(([key]) => key));
        logger.error(
          { siteId, accountId, environment, createUrl, error: error instanceof Error ? error.message : 'Unknown error' },
          'Failed to bulk create env vars'
        );
      }
    }

    // Update existing vars one by one (using PATCH to update value for specific context)
    for (const [key, value] of existingVarsEntries) {
      const updateUrl = `${NETLIFY_API_BASE}/accounts/${accountId}/env/${encodeURIComponent(key)}?site_id=${siteId}`;
      try {
        await netlifyFetch(
          updateUrl,
          accessToken,
          {
            method: 'PATCH',
            body: JSON.stringify({
              context: environment,
              value,
            }),
          }
        );
        updated++;
      } catch (error) {
        failed++;
        failedKeys.push(key);
        logger.error(
          { key, siteId, accountId, environment, updateUrl, error: error instanceof Error ? error.message : 'Unknown error' },
          'Failed to update env var'
        );
      }
    }

    logger.info({ siteId, created, updated, failed, failedKeys }, 'Completed setEnvVars');

    // If all operations failed, throw an error
    if (failed > 0 && created === 0 && updated === 0) {
      throw new NetlifyProviderError(
        `Failed to set all ${failed} environment variables`,
        'all_operations_failed',
        0
      );
    }

    return { created, updated, failed, failedKeys };
  },

  async deleteEnvVar(
    accessToken: string,
    siteId: string,
    environment: string,
    key: string
  ): Promise<void> {
    // First, get the site to retrieve the account_id (required for new API)
    logger.debug({ siteId, key, environment }, 'Starting deleteEnvVar');
    const site = await netlifyFetch<NetlifySite>(
      `${NETLIFY_API_BASE}/sites/${siteId}`,
      accessToken
    );
    const accountId = site.account_id;

    // Use account-level endpoint to delete only one context value
    // DELETE /accounts/{account_id}/env/{key}/value?site_id={site_id}&context={context}
    const deleteUrl = `${NETLIFY_API_BASE}/accounts/${accountId}/env/${encodeURIComponent(key)}/value?site_id=${siteId}&context=${encodeURIComponent(environment)}`;
    logger.debug({ deleteUrl, key, environment }, 'Deleting env var');

    await netlifyFetch(
      deleteUrl,
      accessToken,
      { method: 'DELETE' }
    );
    logger.info({ siteId, key, environment }, 'Successfully deleted env var');
  },

  async deleteEnvVars(
    accessToken: string,
    siteId: string,
    environment: string,
    keys: string[]
  ): Promise<{ deleted: number; failed: number; failedKeys: string[] }> {
    logger.debug({ siteId, environment, keyCount: keys.length }, 'Starting deleteEnvVars');

    // Get the site once for all deletes (optimization)
    const site = await netlifyFetch<NetlifySite>(
      `${NETLIFY_API_BASE}/sites/${siteId}`,
      accessToken
    );
    const accountId = site.account_id;
    logger.debug({ siteId, accountId }, 'Got site info for deleteEnvVars');

    let deleted = 0;
    let failed = 0;
    const failedKeys: string[] = [];

    for (const key of keys) {
      const deleteUrl = `${NETLIFY_API_BASE}/accounts/${accountId}/env/${encodeURIComponent(key)}/value?site_id=${siteId}&context=${encodeURIComponent(environment)}`;
      try {
        await netlifyFetch(
          deleteUrl,
          accessToken,
          { method: 'DELETE' }
        );
        deleted++;
      } catch (error) {
        failed++;
        failedKeys.push(key);
        logger.error(
          { key, siteId, accountId, environment, deleteUrl, error: error instanceof Error ? error.message : 'Unknown error' },
          'Failed to delete env var'
        );
      }
    }

    logger.info({ siteId, deleted, failed, failedKeys }, 'Completed deleteEnvVars');

    if (failed > 0 && deleted === 0) {
      throw new NetlifyProviderError(
        `Failed to delete all ${failed} environment variables`,
        'all_operations_failed',
        0
      );
    }

    return { deleted, failed, failedKeys };
  },
};

// Register the provider
registerProvider(netlifyProvider);

export { NetlifyProviderError };
